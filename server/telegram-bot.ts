import TelegramBot from 'node-telegram-bot-api';
import { IStorage } from './storage';
import { InsertUser } from '@shared/schema';

interface UserRegistrationState {
  step: 'event_selection' | 'full_name' | 'phone' | 'transport_type' | 'transport_model' | 'confirm_existing_data';
  eventId?: number;
  fullName?: string;
  phone?: string;
  transportType?: 'monowheel' | 'scooter' | 'spectator';
  telegramNickname?: string;
  existingData?: {
    fullName: string;
    phone: string;
  };
}

const userStates = new Map<string, UserRegistrationState>();

export async function startTelegramBot(token: string, storage: IStorage) {
  const bot = new TelegramBot(token, { polling: true });

  // Handle /start command
  bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id.toString();
    const telegramId = msg.from?.id.toString();
    const telegramNickname = msg.from?.username;

    if (!telegramId) {
      return bot.sendMessage(chatId, "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.");
    }

    // Only allow registration in private chats
    if (msg.chat.type !== 'private') {
      return bot.sendMessage(
        chatId,
        "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –ª–∏—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö —Å –±–æ—Ç–æ–º. –ù–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ –≤ –ª–∏—á–∫—É –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –Ω–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ!"
      );
    }

    try {
      // Check if user is already registered
      const existingUser = await storage.getUserByTelegramId(telegramId);
      if (existingUser && existingUser.isActive) {
        const event = await storage.getEvent(existingUser.eventId);
        const transportInfo = existingUser.transportModel 
          ? `${getTransportTypeLabel(existingUser.transportType)} (${existingUser.transportModel})`
          : getTransportTypeLabel(existingUser.transportType);

        return bot.sendMessage(
          chatId,
          `–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ "${event?.name}"!\n\n` +
          `üìã –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ:\n` +
          `üë§ –§–ò–û: ${existingUser.fullName}\n` +
          `üì± –¢–µ–ª–µ—Ñ–æ–Ω: ${existingUser.phone}\n` +
          `üöó –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç: ${transportInfo}\n` +
          `üè∑Ô∏è –ù–æ–º–µ—Ä —É—á–∞—Å—Ç–Ω–∏–∫–∞: ${existingUser.participantNumber}\n\n` +
          `–ß—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ –∏–ª–∏ –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è –æ—Ç —É—á–∞—Å—Ç–∏—è, –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:`,
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: "–ò–∑–º–µ–Ω–∏—Ç—å —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞", callback_data: "change_transport" }],
                [{ text: "–û—Ç–∫–∞–∑–∞—Ç—å—Å—è –æ—Ç —É—á–∞—Å—Ç–∏—è", callback_data: "cancel_participation" }],
              ],
            },
          }
        );
      }

      // Get all active events (not limited by chat)
      const activeEvents = await storage.getActiveEvents();
      if (activeEvents.length === 0) {
        return bot.sendMessage(
          chatId,
          "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏."
        );
      }

      // Initialize registration state
      userStates.set(telegramId, {
        step: 'event_selection',
        telegramNickname,
      });

      if (activeEvents.length === 1) {
        // Auto-select single event, but check for existing data first
        const existingRegistrations = await storage.getUserRegistrationsByTelegramId(telegramId);
        
        if (existingRegistrations.length > 0) {
          // Show existing user data for confirmation
          const lastRegistration = existingRegistrations[existingRegistrations.length - 1];
          
          userStates.set(telegramId, {
            step: 'confirm_existing_data',
            eventId: activeEvents[0].id,
            telegramNickname,
            existingData: {
              fullName: lastRegistration.fullName,
              phone: lastRegistration.phone,
            }
          });

          return bot.sendMessage(
            chatId,
            `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è!\n\n` +
            `üìÖ ${activeEvents[0].name}\n` +
            `üìç ${activeEvents[0].location}\n` +
            `üïê ${formatDateTime(activeEvents[0].datetime)}\n\n` +
            `üìã –ù–∞–π–¥–µ–Ω—ã –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–π:\n` +
            `üë§ –§–ò–û: ${lastRegistration.fullName}\n` +
            `üì± –¢–µ–ª–µ—Ñ–æ–Ω: ${lastRegistration.phone}\n\n` +
            `–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏?`,
            {
              reply_markup: {
                inline_keyboard: [
                  [
                    { text: "‚úÖ –î–∞, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å", callback_data: "use_existing_data" },
                    { text: "‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ", callback_data: "change_data" }
                  ]
                ]
              }
            }
          );
        }

        // No existing data - proceed with normal registration
        userStates.set(telegramId, {
          step: 'full_name',
          eventId: activeEvents[0].id,
          telegramNickname,
        });

        return bot.sendMessage(
          chatId,
          `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è!\n\n` +
          `üìÖ ${activeEvents[0].name}\n` +
          `üìç ${activeEvents[0].location}\n` +
          `üïê ${formatDateTime(activeEvents[0].datetime)}\n\n` +
          `–î–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –º–Ω–µ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–∞–Ω–Ω—ã—Ö.\n` +
          `–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à–∏ –§–ò–û:`
        );
      } else {
        // Multiple events - show selection
        const keyboard = activeEvents.map(event => [{
          text: `${event.name} - ${formatDateTime(event.datetime)}`,
          callback_data: `select_event_${event.id}`,
        }]);

        return bot.sendMessage(
          chatId,
          "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:",
          {
            reply_markup: {
              inline_keyboard: keyboard,
            },
          }
        );
      }
    } catch (error) {
      console.error('Telegram bot error:', error);
      bot.sendMessage(chatId, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
    }
  });

  // Handle callback queries
  bot.on('callback_query', async (query) => {
    const chatId = query.message?.chat.id.toString();
    const telegramId = query.from.id.toString();
    const data = query.data;

    console.log(`Received callback query: ${data} from user ${telegramId}`);

    if (!chatId || !data) return;

    try {
      await bot.answerCallbackQuery(query.id);

      if (data.startsWith('select_event_')) {
        const eventId = parseInt(data.replace('select_event_', ''));
        const event = await storage.getEvent(eventId);
        
        if (!event) {
          return bot.sendMessage(chatId, "–ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.");
        }

        // Check if user already has existing registrations
        const existingRegistrations = await storage.getUserRegistrationsByTelegramId(telegramId);
        
        if (existingRegistrations.length > 0) {
          // Show existing user data for confirmation
          const lastRegistration = existingRegistrations[existingRegistrations.length - 1];
          
          userStates.set(telegramId, {
            step: 'confirm_existing_data',
            eventId,
            telegramNickname: query.from.username,
            existingData: {
              fullName: lastRegistration.fullName,
              phone: lastRegistration.phone,
            }
          });

          return bot.sendMessage(
            chatId,
            `–í—ã –≤—ã–±—Ä–∞–ª–∏: "${event.name}"\n\n` +
            `üìã –ù–∞–π–¥–µ–Ω—ã –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–π:\n` +
            `üë§ –§–ò–û: ${lastRegistration.fullName}\n` +
            `üì± –¢–µ–ª–µ—Ñ–æ–Ω: ${lastRegistration.phone}\n\n` +
            `–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏?`,
            {
              reply_markup: {
                inline_keyboard: [
                  [
                    { text: "‚úÖ –î–∞, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å", callback_data: "use_existing_data" },
                    { text: "‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ", callback_data: "change_data" }
                  ]
                ]
              }
            }
          );
        }

        // No existing data - proceed with normal registration
        userStates.set(telegramId, {
          step: 'full_name',
          eventId,
          telegramNickname: query.from.username,
        });

        return bot.sendMessage(
          chatId,
          `–í—ã –≤—ã–±—Ä–∞–ª–∏: "${event.name}"\n\n` +
          `–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à–∏ –§–ò–û:`
        );
      }

      if (data === 'change_transport') {
        const user = await storage.getUserByTelegramId(telegramId);
        if (!user) return;

        userStates.set(telegramId, {
          step: 'transport_type',
          eventId: user.eventId,
        });

        return bot.sendMessage(
          chatId,
          "–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞:",
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: "üõû –ú–æ–Ω–æ–∫–æ–ª–µ—Å–æ", callback_data: "transport_monowheel" }],
                [{ text: "üõ¥ –°–∞–º–æ–∫–∞—Ç", callback_data: "transport_scooter" }],
                [{ text: "üëÄ –ó—Ä–∏—Ç–µ–ª—å", callback_data: "transport_spectator" }],
              ],
            },
          }
        );
      }

      if (data === 'use_existing_data') {
        const state = userStates.get(telegramId);
        if (!state || !state.existingData || !state.eventId) {
          return bot.sendMessage(chatId, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.");
        }

        // Use existing data, go straight to transport type selection
        userStates.set(telegramId, {
          ...state,
          step: 'transport_type',
          fullName: state.existingData.fullName,
          phone: state.existingData.phone,
        });

        return bot.sendMessage(
          chatId,
          `–û—Ç–ª–∏—á–Ω–æ! –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ:\n` +
          `üë§ –§–ò–û: ${state.existingData.fullName}\n` +
          `üì± –¢–µ–ª–µ—Ñ–æ–Ω: ${state.existingData.phone}\n\n` +
          `–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞:`,
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: "üõ¥ –ú–æ–Ω–æ–∫–æ–ª–µ—Å–æ", callback_data: "transport_monowheel" }],
                [{ text: "üõµ –°–∞–º–æ–∫–∞—Ç", callback_data: "transport_scooter" }],
                [{ text: "üëÄ –ó—Ä–∏—Ç–µ–ª—å", callback_data: "transport_spectator" }],
              ],
            },
          }
        );
      }

      if (data === 'change_data') {
        const state = userStates.get(telegramId);
        if (!state || !state.eventId) {
          return bot.sendMessage(chatId, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.");
        }

        // Start fresh registration process
        userStates.set(telegramId, {
          step: 'full_name',
          eventId: state.eventId,
          telegramNickname: state.telegramNickname,
        });

        return bot.sendMessage(
          chatId,
          `–•–æ—Ä–æ—à–æ, –≤–≤–µ–¥—ë–º –¥–∞–Ω–Ω—ã–µ –∑–∞–Ω–æ–≤–æ.\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à–∏ –§–ò–û:`
        );
      }

      if (data === 'cancel_participation') {
        const user = await storage.getUserByTelegramId(telegramId);
        if (user) {
          await storage.deactivateUser(user.id);
          return bot.sendMessage(
            chatId,
            "–í—ã –æ—Ç–∫–∞–∑–∞–ª–∏—Å—å –æ—Ç —É—á–∞—Å—Ç–∏—è –≤ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–∏. –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã, –Ω–æ —É—á–∞—Å—Ç–∏–µ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ."
          );
        }
      }

      if (data.startsWith('transport_')) {
        const transportType = data.replace('transport_', '') as 'monowheel' | 'scooter' | 'spectator';
        const state = userStates.get(telegramId);
        
        console.log(`Transport selection: ${transportType}, user state:`, state);
        
        if (!state) {
          console.log(`No state found for user ${telegramId}`);
          return;
        }

        // Check if this is updating an existing user
        const existingUser = await storage.getUserByTelegramId(telegramId);
        if (existingUser && state.step === 'transport_type') {
          // For scooter and monowheel, ask for model before updating
          if (transportType === 'scooter' || transportType === 'monowheel') {
            userStates.set(telegramId, {
              ...state,
              step: 'transport_model',
              transportType,
            });
            
            return bot.sendMessage(
              chatId,
              `–í—ã –≤—ã–±—Ä–∞–ª–∏ ${getTransportTypeLabel(transportType)}. –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ –º–æ–¥–µ–ª—å:`
            );
          } else {
            // For spectator, update immediately
            await storage.updateUser(existingUser.id, { transportType, transportModel: null });
            userStates.delete(telegramId);
            return bot.sendMessage(
              chatId,
              `–¢–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ –∏–∑–º–µ–Ω—ë–Ω –Ω–∞: ${getTransportTypeLabel(transportType)}`
            );
          }
        }

        // For new registration, check if we need model
        if (transportType === 'scooter' || transportType === 'monowheel') {
          userStates.set(telegramId, {
            ...state,
            step: 'transport_model',
            transportType,
          });
          
          return bot.sendMessage(
            chatId,
            `–í—ã –≤—ã–±—Ä–∞–ª–∏ ${getTransportTypeLabel(transportType)}. –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ –º–æ–¥–µ–ª—å:`
          );
        }

        // Complete new registration for spectator
        if (state.eventId && state.fullName && state.phone && state.step === 'transport_type') {
          const userData: InsertUser = {
            telegramId,
            telegramNickname: state.telegramNickname || null,
            fullName: state.fullName,
            phone: state.phone,
            transportType,
            transportModel: null,
            eventId: state.eventId,
            isActive: true,
          };

          const user = await storage.createUser(userData);
          const event = await storage.getEvent(state.eventId);

          userStates.delete(telegramId);
          return bot.sendMessage(
            chatId,
            `üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã!\n\n` +
            `üìã –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ:\n` +
            `üìÖ –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ: ${event?.name}\n` +
            `üë§ –§–ò–û: ${user.fullName}\n` +
            `üì± –¢–µ–ª–µ—Ñ–æ–Ω: ${user.phone}\n` +
            `üöó –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç: ${getTransportTypeLabel(user.transportType)}\n` +
            `üè∑Ô∏è –í–∞—à –Ω–æ–º–µ—Ä —É—á–∞—Å—Ç–Ω–∏–∫–∞: ${user.participantNumber}\n\n` +
            `–í—ã –º–æ–∂–µ—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å –º–Ω–µ —Å–Ω–æ–≤–∞, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ –∏–ª–∏ –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è –æ—Ç —É—á–∞—Å—Ç–∏—è.`
          );
        }
      }
    } catch (error) {
      console.error('Callback query error:', error);
      bot.sendMessage(chatId, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
    }
  });

  // Handle text messages
  bot.on('message', async (msg) => {
    if (msg.text?.startsWith('/')) return; // Skip commands

    const chatId = msg.chat.id.toString();
    const telegramId = msg.from?.id.toString();
    const text = msg.text;

    if (!telegramId || !text) return;

    const state = userStates.get(telegramId);
    if (!state) return;

    try {
      if (state.step === 'full_name') {
        if (text.length < 2) {
          return bot.sendMessage(chatId, "–§–ò–û –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑:");
        }

        userStates.set(telegramId, {
          ...state,
          step: 'phone',
          fullName: text,
        });

        return bot.sendMessage(
          chatId,
          "–°–ø–∞—Å–∏–±–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n+7 (XXX) XXX-XX-XX"
        );
      }

      if (state.step === 'phone') {
        const phoneRegex = /^\+7 \(\d{3}\) \d{3}-\d{2}-\d{2}$/;
        if (!phoneRegex.test(text)) {
          return bot.sendMessage(
            chatId,
            "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–µ–ª–µ—Ñ–æ–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç: +7 (XXX) XXX-XX-XX\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑:"
          );
        }

        userStates.set(telegramId, {
          ...state,
          step: 'transport_type',
          phone: text,
        });

        return bot.sendMessage(
          chatId,
          "–û—Ç–ª–∏—á–Ω–æ! –ü–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥ - –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞:",
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: "üõû –ú–æ–Ω–æ–∫–æ–ª–µ—Å–æ", callback_data: "transport_monowheel" }],
                [{ text: "üõ¥ –°–∞–º–æ–∫–∞—Ç", callback_data: "transport_scooter" }],
                [{ text: "üëÄ –ó—Ä–∏—Ç–µ–ª—å", callback_data: "transport_spectator" }],
              ],
            },
          }
        );
      }

      if (state.step === 'transport_model') {
        if (text.length < 2) {
          return bot.sendMessage(chatId, "–ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑:");
        }

        // Check if this is updating an existing user
        const existingUser = await storage.getUserByTelegramId(telegramId);
        if (existingUser) {
          await storage.updateUser(existingUser.id, { 
            transportType: state.transportType!, 
            transportModel: text 
          });
          userStates.delete(telegramId);
          return bot.sendMessage(
            chatId,
            `–¢–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ –∏–∑–º–µ–Ω—ë–Ω –Ω–∞: ${getTransportTypeLabel(state.transportType!)} (${text})`
          );
        }

        // Complete new registration
        if (state.eventId && state.fullName && state.phone && state.transportType) {
          const userData: InsertUser = {
            telegramId,
            telegramNickname: state.telegramNickname || null,
            fullName: state.fullName,
            phone: state.phone,
            transportType: state.transportType!,
            transportModel: text,
            eventId: state.eventId,
            isActive: true,
          };

          const user = await storage.createUser(userData);
          const event = await storage.getEvent(state.eventId);

          userStates.delete(telegramId);
          return bot.sendMessage(
            chatId,
            `üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã!\n\n` +
            `üìã –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ:\n` +
            `üìÖ –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ: ${event?.name}\n` +
            `üë§ –§–ò–û: ${user.fullName}\n` +
            `üì± –¢–µ–ª–µ—Ñ–æ–Ω: ${user.phone}\n` +
            `üöó –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç: ${getTransportTypeLabel(user.transportType)} (${user.transportModel})\n` +
            `üè∑Ô∏è –í–∞—à –Ω–æ–º–µ—Ä —É—á–∞—Å—Ç–Ω–∏–∫–∞: ${user.participantNumber}\n\n` +
            `–í—ã –º–æ–∂–µ—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å –º–Ω–µ —Å–Ω–æ–≤–∞, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ –∏–ª–∏ –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è –æ—Ç —É—á–∞—Å—Ç–∏—è.`
          );
        }
      }
    } catch (error) {
      console.error('Message handling error:', error);
      bot.sendMessage(chatId, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
    }
  });

  console.log(`Telegram bot started with token: ${token.substring(0, 10)}...`);

  // Export bot instance for external use
  return bot;
}

export async function sendEventNotificationToGroup(
  bot: TelegramBot, 
  chatId: string, 
  eventData: {
    name: string;
    location: string;
    datetime: Date;
    monowheelCount: number;
    scooterCount: number;
    spectatorCount: number;
    totalCount: number;
  }
) {
  const message = `üèÅ –£–í–ï–î–û–ú–õ–ï–ù–ò–ï –û –ú–ï–†–û–ü–†–ò–Ø–¢–ò–ò üèÅ\n\n` +
    `üìÖ ${eventData.name}\n` +
    `üìç ${eventData.location}\n` +
    `üïê ${formatDateTime(eventData.datetime)}\n\n` +
    `üìä –¢–ï–ö–£–©–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê –£–ß–ê–°–¢–ù–ò–ö–û–í:\n` +
    `üõû –ú–æ–Ω–æ–∫–æ–ª–µ—Å–æ: ${eventData.monowheelCount} —á–µ–ª.\n` +
    `üõ¥ –°–∞–º–æ–∫–∞—Ç: ${eventData.scooterCount} —á–µ–ª.\n` +
    `üëÄ –ó—Ä–∏—Ç–µ–ª–∏: ${eventData.spectatorCount} —á–µ–ª.\n` +
    `üìã –í—Å–µ–≥–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ: ${eventData.totalCount} —á–µ–ª.\n\n` +
    `ü§ñ –î–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É /start`;

  try {
    await bot.sendMessage(chatId, message);
    console.log(`Event notification sent to group ${chatId}`);
  } catch (error) {
    console.error(`Failed to send notification to group ${chatId}:`, error);
    throw error;
  }
}

function getTransportTypeLabel(type: string): string {
  switch (type) {
    case 'monowheel': return '–ú–æ–Ω–æ–∫–æ–ª–µ—Å–æ';
    case 'scooter': return '–°–∞–º–æ–∫–∞—Ç';
    case 'spectator': return '–ó—Ä–∏—Ç–µ–ª—å';
    default: return type;
  }
}

function formatDateTime(date: Date): string {
  return new Intl.DateTimeFormat('ru-RU', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  }).format(new Date(date));
}
